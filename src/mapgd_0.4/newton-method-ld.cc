/*This code was automatically generated by extras/automatic_src/make_tangent_ld.py*/

#include "newton-method-ld.h"

float_t H0 (const Population &P1, const Population &P2, const float_t &D) {
	float_t sum=0;
	float_t Q1=P1.m;
	float_t Q2=P2.m;
	float_t f=(P1.f+P2.f)/2.;
	int p_size=P1.likelihoods.size();
	Constants<float, std::tuple<const Population &, const Population &, const float_t &> > con(LD_CNTS, LD_ARRAY);
	con.recalculate( std::tuple<const Population &, const Population &, const float_t &> (P1, P2, D));
	for (int x=0; x<p_size; ++x) {
		float_t MM1=P1.likelihoods[x].MM;
		float_t Mm1=P1.likelihoods[x].Mm;
		float_t mm1=P1.likelihoods[x].mm;
		float_t MM2=P2.likelihoods[x].MM;
		float_t Mm2=P2.likelihoods[x].Mm;
		float_t mm2=P2.likelihoods[x].mm;
		if (P1.likelihoods[x].N > 0 and P2.likelihoods[x].N > 0){
		sum+=(MM1*MM2*con.c[12] + 2*MM1*Mm2*con.c[0]*con.c[8] + 2*MM1*Mm2*con.c[10]*con.c[8] + MM1*con.c[13]*mm2 + 2*MM2*Mm1*con.c[0]*con.c[8] + 2*MM2*Mm1*con.c[11]*con.c[8] + MM2*con.c[14]*mm1 - 2*Mm1*Mm2*con.c[16]*con.c[8] + 2*Mm1*con.c[10]*con.c[8]*mm2 + 2*Mm1*con.c[6]*con.c[8]*mm2 + 2*Mm2*con.c[11]*con.c[8]*mm1 + 2*Mm2*con.c[6]*con.c[8]*mm1 + con.c[15]*mm1*mm2)/(-MM1*MM2*con.c[0]*con.c[1] + 2*MM1*Mm2*con.c[0]*con.c[10]*con.c[8] - MM1*con.c[2]*con.c[3]*mm2 + 2*MM2*Mm1*con.c[0]*con.c[11]*con.c[8] - MM2*con.c[4]*con.c[5]*mm1 - 2*Mm1*Mm2*con.c[8]*con.c[9] + 2*Mm1*con.c[10]*con.c[6]*con.c[8]*mm2 + 2*Mm2*con.c[11]*con.c[6]*con.c[8]*mm1 - con.c[6]*con.c[7]*mm1*mm2) ;
}

	}
	return sum;
}

float_t J00 (const Population &P1, const Population &P2, const float_t &D) {
	float_t sum=0;
	float_t Q1=P1.m;
	float_t Q2=P2.m;
	float_t f=(P1.f+P2.f)/2.;
	int p_size=P1.likelihoods.size();
	Constants<float, std::tuple<const Population &, const Population &, const float_t &> > con(LD_CNTS, LD_ARRAY);
	con.recalculate( std::tuple<const Population &, const Population &, const float_t &> (P1, P2, D));
	for (int x=0; x<p_size; ++x) {
		float_t MM1=P1.likelihoods[x].MM;
		float_t Mm1=P1.likelihoods[x].Mm;
		float_t mm1=P1.likelihoods[x].mm;
		float_t MM2=P2.likelihoods[x].MM;
		float_t Mm2=P2.likelihoods[x].Mm;
		float_t mm2=P2.likelihoods[x].mm;
		if (P1.likelihoods[x].N > 0 and P2.likelihoods[x].N > 0){
		sum+=(MM1*MM2*con.c[28] - 4*MM1*Mm2*con.c[21] + MM1*con.c[28]*mm2 - 4*MM2*Mm1*con.c[21] + MM2*con.c[28]*mm1 + 8*Mm1*Mm2*con.c[21] - 4*Mm1*con.c[21]*mm2 - 4*Mm2*con.c[21]*mm1 + con.c[28]*mm1*mm2)/(MM1*MM2*con.c[17] + MM1*Mm2*con.c[21]*con.c[23]*con.c[24] + MM1*con.c[18]*mm2 + MM2*Mm1*con.c[21]*con.c[25]*con.c[26] + MM2*con.c[19]*mm1 + Mm1*Mm2*con.c[21]*con.c[22] + Mm1*con.c[21]*con.c[24]*con.c[6]*mm2 + Mm2*con.c[21]*con.c[27]*con.c[6]*mm1 + con.c[20]*mm1*mm2) + (-MM1*MM2*con.c[29] + 2*MM1*Mm2*con.c[21]*con.c[23] - MM1*Mm2*con.c[21]*con.c[24] - MM1*con.c[30]*mm2 - 2*MM2*Mm1*con.c[21]*con.c[25] + MM2*Mm1*con.c[21]*con.c[26] - MM2*con.c[31]*mm1 - Mm1*Mm2*con.c[21]*con.c[33] - Mm1*con.c[21]*con.c[24]*mm2 + 2*Mm1*con.c[21]*con.c[6]*mm2 - Mm2*con.c[21]*con.c[27]*mm1 + 2*Mm2*con.c[21]*con.c[6]*mm1 - con.c[32]*mm1*mm2)*(MM1*MM2*con.c[29] - 2*MM1*Mm2*con.c[21]*con.c[23] + MM1*Mm2*con.c[21]*con.c[24] + MM1*con.c[30]*mm2 + 2*MM2*Mm1*con.c[21]*con.c[25] - MM2*Mm1*con.c[21]*con.c[26] + MM2*con.c[31]*mm1 + Mm1*Mm2*con.c[21]*con.c[33] + Mm1*con.c[21]*con.c[24]*mm2 - 2*Mm1*con.c[21]*con.c[6]*mm2 + Mm2*con.c[21]*con.c[27]*mm1 - 2*Mm2*con.c[21]*con.c[6]*mm1 + con.c[32]*mm1*mm2)/pow(MM1*MM2*con.c[17] + MM1*Mm2*con.c[21]*con.c[23]*con.c[24] + MM1*con.c[18]*mm2 + MM2*Mm1*con.c[21]*con.c[25]*con.c[26] + MM2*con.c[19]*mm1 + Mm1*Mm2*con.c[21]*con.c[22] + Mm1*con.c[21]*con.c[24]*con.c[6]*mm2 + Mm2*con.c[21]*con.c[27]*con.c[6]*mm1 + con.c[20]*mm1*mm2, 2) ;
}

	}
	return sum;
}

