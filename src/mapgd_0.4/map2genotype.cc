/* 

command filter:

*/

#include "map2genotype.h"

//This should probably be changed over to a likelihood model class and be a static method of genotype
Genotype 
baysian_genotype(const int &major, const int &minor, const float_t &freq, const float_t &error, const quartet_t &quart)
{

	float_t lMM, lMm, lmm, N;

	N=count(quart);

	float_t M=quart.base[major], m=quart.base[minor];
	float_t E=N-M-m;

	float_t ln_homozygous_correct=log(1.-error);
	float_t ln_heterozygous_correct=log( (1.-error)/2.+error/6.);
	float_t not_correct=log(error/3.);

	lMM=M*ln_homozygous_correct+not_correct*(m+E);
	lMm=(M+m)*ln_heterozygous_correct+not_correct*E;//#-log(1.001);
	lmm=m*ln_homozygous_correct+not_correct*(M+E);

//	MM=M*lnc+notc*(m+E)
//	Mm=(M+m)*lnch+notc*(E)-math.log(1.01)
//	mm=m*lnc+notc*(M+E)/

	float_t norm=log(exp(lMM)+exp(lMm)+exp(lmm) );

	if (N>0.01){
		lMM-=norm;
		lMm-=norm;
		lmm-=norm;
	} else {
		lMM=log(1./3.);
		lMm=log(1./3.);
		lmm=log(1./3.);
	}

//	std::cerr << ln_homozygous_correct << std::endl; 
//	std::cerr << ln_heterozygous_correct << std::endl; 
//	std::cerr << not_correct << std::endl; 
//	std::cerr << major << ", " << minor << ":" << quart << ", N:" << N << ", M:" <<M << ", m:"<< m  <<", E:"<< E << std::endl; 
//	std::cerr << error << ":" << quart << ", lMM:" << lMM << ", lMm:" << lMm << ", lmm:"<< lmm  << std::endl; 

	return Genotype(-lMM, -lMm, -lmm, N);	
//	return Genotype(lMM, lMm, lmm, 0);	
}

void get_genotypes(const Allele &allele, const Locus &locus, Population &genotypes )
{
	std::vector <Genotype>::iterator l_it=genotypes.likelihoods.begin();
	std::vector <quartet_t>::const_iterator q_it=locus.cbegin(), q_end=locus.cend();
	while (q_it != q_end){
		*l_it=baysian_genotype(allele.major, allele.minor, allele.freq, allele.error, *q_it);
		q_it++;
		l_it++;
	}
	genotypes.m=1.-allele.freq;
	genotypes.major=allele.major;
	genotypes.minor=allele.minor;
	genotypes.set_abs_pos(allele.get_abs_pos() );
} 
 

int map2genotype(int argc, char *argv[])
{

	/* All the variables that can be set from the command line */

	bool binary=false;

	std::string mapname="", proname="", outname="";

	Environment env;
	env.set_name("mapgd genotype");
	env.set_version(VERSION);
	env.set_author("Matthew Ackerman");
	env.set_description("convert a map and pro file to an individual genotype file.");
	env.required_arg('m',"map", mapname, "please provide a 'map' filename.", "the name of the map file.");
	env.required_arg('p',"pro", proname, "please provide a 'pro' filename.", "the name of the pro file (should be generated by the -p option of mapgd allele, not mapgd proview).");
	env.optional_arg('o',"output", outname, "please provide a 'gcf' filename.", "the name of the output file.");
	env.flag(	'v', "version", &env, 		&flag_version, 	"an error occurred while displaying the version message.", "prints the program version");
	env.flag(	'h', "help", &env, 		&flag_help, 	"an error occurred while displaying the help message.", "prints the program version");
	env.flag(	'b', "binary", &binary, 	&flag_set, 	"an error occurred while setting binary mode.", "binary output");

	if (parsargs(argc, argv, env) ) print_usage(env); //Gets all the command line options, and prints usage on failure.

	/* The files we will need*/
	Indexed_file <Allele> map_in;
	Indexed_file <Locus> pro_in;
	Indexed_file <Population> gcf_out;

	/* Open input files based on file name*/
	map_in.open(mapname.c_str(), std::ios::in);
	pro_in.open(proname.c_str(), std::ios::in);

	if (outname.size()!=0) {
		gcf_out.open(outname.c_str(), binary ? std::ios::out | std::ios::binary : std::ios::out);
	} else {
	/* Just open the output file to std::cout*/
		gcf_out.open(binary ? std::ios::out | std::ios::binary : std::ios::out);
	}
	/* We need one instance of each of the classes for reading and 
	 * writing to files */
	Locus pro_record;
	Allele map_record;
	Population gcf_record;

	/* Read the headers of the files */
	map_record=map_in.read_header();	
	pro_record=pro_in.read_header();	

	/* Set the sample names for the gcf file from the sample names in the pro_file*/
	gcf_record.set_sample_names(pro_record.get_sample_names() );
	gcf_out.set_index(map_in.get_index() );

	/* Write the header */
	gcf_out.write_header(gcf_record);

	id1_t map_pos;	
	map_in.read(map_record);
	
	while(map_in.table_is_open() ){
	/* a read/write cycle */
		map_pos=map_in.get_pos(map_record);
		while(pro_in.get_pos(pro_record)<map_pos && !pro_in.eof() ){
			pro_in.read(pro_record);
		}
		if (map_pos==pro_in.get_pos(pro_record) ){
			get_genotypes(map_record, pro_record, gcf_record);
			gcf_out.write(gcf_record);
		}
		map_in.read(map_record);
	}
	gcf_out.close();

	return 0;					//Since everything worked, return 0!.
}
