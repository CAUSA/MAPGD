import math
import sympy
import sys
from sympy.utilities.codegen import codegen
from sympy.printing import print_ccode


#The Data
mm1=sympy.Symbol('b.mm1')
Mm1=sympy.Symbol('b.Mm1')
MM1=sympy.Symbol('b.MM1')
mm2=sympy.Symbol('b.mm2')
Mm2=sympy.Symbol('b.Mm2')
MM2=sympy.Symbol('b.MM2')
p=sympy.Symbol('b.P')

#The parameters
FA=sympy.Symbol('a.FA')
FC=sympy.Symbol('a.FC')
r=sympy.Symbol('a.r')
sA=sympy.Symbol('a.sA')
sC=sympy.Symbol('a.sC')
z1=sympy.Symbol('a.z1')
z2=sympy.Symbol('a.z2')

params=[FA, FC, r, sA, sC, z1, z2]

q=(1-p)
Va=(1-p)*p
ga=-2*p**3+3*p**2-p
gc=-2*p**3+3*p**2-p
ka=-6*p**4+12*p**3-7*p**2+p+3*Va**2

mm1mm2=(q**4+(FA+FC+4*r)*q**2*Va+2*(sA+sC)*q*ga+z1*ka+z2*Va**2 )*sympy.exp(-mm1)*sympy.exp(-mm2)
Mm1mm2=(2*p*q**3+2*(FC*p*q-FA*q**2-2*r*(q**2-p*q))*Va-4*sA*ga*q+2*sC*ga*(p-q)-2*z1*ka-2*z2*Va**2)*sympy.exp(-Mm1)*sympy.exp(-mm2)
MM1mm2=(p**2*q**2+(FC*p**2+FA*q**2-4*r*p*q)*Va+2*sA*ga*q-2*sC*ga*p+z1*ka+z2*Va**2)*sympy.exp(-MM1)*sympy.exp(-mm2)
mm1Mm2=(2*p*q**3+2*(FA*p*q-FC*q**2-2*r*(q**2-p*q))*Va-4*sC*ga*q+2*sA*ga*(p-q)-2*z1*ka-2*z2*Va**2)*sympy.exp(-mm1)*sympy.exp(-Mm2)
Mm1Mm2=(4*p**2*q**2+4*(r*(p**2+q**2-2*p*q)-FA*p*q-FC*p*q)*Va+4*(sC+sA)*(q-p)*ga+4*z1*ka+4*z2*Va**2)*sympy.exp(-Mm1)*sympy.exp(-Mm2)
MM1Mm2=(2*q*p**3+2*(FA*p*q-FC*p**2-2*r*(p**2-p*q) )*Va+4*sC*ga*p-2*sA*ga*(q-p)-2*z1*ka-2*z2*Va**2)*sympy.exp(-MM1)*sympy.exp(-Mm2)
mm1MM2=(p**2*q**2+(FA*p**2+FC*q**2-4*r*p*q)*Va+2*sC*ga*q-2*sA*ga*p+z1*ka+z2*Va**2)*sympy.exp(-mm1)*sympy.exp(-MM2)
Mm1MM2=(2*q*p**3+2*(FC*p*q-FA*p**2-2*r*(p**2-p*q) )*Va+4*sA*ga*p-2*sC*ga*(q-p)-2*z1*ka-2*z2*Va**2)*sympy.exp(-Mm1)*sympy.exp(-MM2)
MM1MM2=(p**4+(FA+FC+4*r)*p**2*Va-2*(sA+sC)*p*ga+z1*ka+z2*Va**2)*sympy.exp(-MM1)*sympy.exp(-MM2)


lnL=sympy.log(mm1mm2+Mm1mm2+MM1mm2+mm1Mm2+Mm1Mm2+MM1Mm2+mm1MM2+Mm1MM2+MM1MM2)

system_eq=[]

#We first need the three equations we are going to try and set to zero, i.e. the first partial derivitives wrt e h and F.
print "/*This code was automatically generated by "+str(sys.argv[0])+"*/\n"

print "#ifndef _NEWTON_RHO_H_"
print "#define _NEWTON_RHO_H_"

print "#include \"rml.h\""
print
for x in range(0, 7):
        system_eq.append(sympy.diff(lnL, params[x]) )
        print "float_t H"+str(x)+" (const likelihood_eq &a, const PAIRGL &b, const ll_t &c) {"
        sys.stdout.write("\treturn ")
        print_ccode(  system_eq[-1] )
        print "*c;\n}\n"

#Then we need to make the Jacobian, which is a matrix with ...
for x in range(0, 7):
        for y in range(0, 7):
        	print "float_t J"+str(x)+str(y)+" (const likelihood_eq &a, const PAIRGL &b, const ll_t &c) {"
                sys.stdout.write("\treturn ")
		print_ccode( (sympy.diff(system_eq[x], params[y]) ) )
                print "*c;\n}\n"

print "float_t lnL_NR (const likelihood_eq &a, const PAIRGL &b, const ll_t &c) {"
sys.stdout.write("\treturn ")
print_ccode(sympy.simplify(lnL) )
print "*c;\n}\n"
print "typedef float_t (*Jfunc_t) (const likelihood_eq &, const PAIRGL &, const ll_t &);"
print "Jfunc_t Jfunc[7][7]={"
print "J00, J01, J02, J03, J04, J05, J06,"
print "J10, J11, J12, J13, J14, J15, J16,"
print "J20, J21, J22, J23, J24, J25, J26,"
print "J30, J31, J32, J33, J34, J35, J36,"
print "J40, J41, J42, J43, J44, J45, J46,"
print "J50, J51, J52, J53, J54, J55, J56,"
print "J60, J61, J62, J63, J64, J65, J66 };"
print
print "typedef float_t (*Hfunc_t) (const likelihood_eq &, const PAIRGL &, const ll_t &);"
print "Hfunc_t Hfunc[7]={H0, H1, H2, H3, H4, H5, H6};"
print
print "#endif"
