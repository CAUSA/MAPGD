import sympy 
import sys
from sympy.utilities.codegen import codegen
from sympy.printing import print_ccode

#The Data
lMM1=sympy.Symbol('lMM1')
lMm1=sympy.Symbol('lMm1')
lmm1=sympy.Symbol('lmm1')

lMM2=sympy.Symbol('lMM2')
lMm2=sympy.Symbol('lMm2')
lmm2=sympy.Symbol('lmm2')

Q1=sympy.Symbol('Q1')
Q2=sympy.Symbol('Q2')

f=sympy.Symbol('f')

P1=(1.-Q1)
P2=(1.-Q2)

#The Parameters
D=sympy.Symbol('D')

#               prob_geno[1] = pow(best_p*best_q+mlD,2.0);                                      // AB/AB
#               prob_geno[2] = pow(best_p*(1.0-best_q)-mlD, 2.0);                               // Ab/Ab
#               prob_geno[3] = pow((1.0-best_p)*best_q-mlD, 2.0);                               // aB/aB
#               prob_geno[4] = pow((1.0-best_p)*(1.0-best_q)+mlD, 2.0);                         // ab/ab
#               prob_geno[5] = 2.0*(best_p*best_q+mlD)*(best_p*(1.0-best_q)-mlD);               // AB/Ab
#               prob_geno[6] = 2.0*((1.0-best_p)*best_q-mlD)*((1.0-best_p)*(1.0-best_q)+mlD);   // aB/ab
#               prob_geno[7] = 2.0*(best_p*best_q+mlD)*((1.0-best_p)*best_q-mlD);               // AB/aB
#               prob_geno[8] = 2.0*(best_p*(1.0-best_q)-mlD)*((1.0-best_p)*(1.0-best_q)+mlD);   // Ab/ab
#               prob_geno[9] = 2.0*(best_p*best_q+mlD)*((1.0-best_p)*(1.0-best_q)+mlD);         // AB/ab
#               prob_geno[10] = 2.0*(best_p*(1.0-best_q)-mlD)*((1.0-best_p)*best_q-mlD);        // Ab/aB


#An array of the parameters.
params=[D]

G00=Q1*Q2+D
G10=P1*Q2-D
G01=Q1*P2-D
G11=P1*P2+D

H00=G00*G00+f*G00*(1-G00)
H10=2*G10*G00*(1-f)
H20=G10*G10+f*G10*(1-G10)
H01=2*G01*G00*(1-f)
H11=(2*G01*G10+2*G11*G00)*(1-f)
H21=2*G10*G11*(1-f)
H02=G01*G01+f*G01*(1-G01)
H12=2*G11*G01*(1-f)
H22=G11*G11+f*G11*(1-G11)

#The log likelihood equation
lnL=sympy.log( H00*sympy.exp(-lmm1-lmm2)+H01*(sympy.exp(-lmm1-lMm2))+H02*sympy.exp(-lmm1-lMM2)+H10*sympy.exp(-lMm1-lmm2)+H11*sympy.exp(-lMm1-lMm2)+H12*sympy.exp(-lMm1-lMM2)+H20*sympy.exp(-lMM1-lmm2)+H21*sympy.exp(-lMM1-lMm2)+H22*sympy.exp(-lMM1-lMM2) )
#lnL=-e**2-h**2-F**2

system_eq=[]

#We first need the three equations we are going to try and set to zero, i.e. the first partial derivitives wrt e h and F.
print "/*This code was automatically generated by "+str(sys.argv[0])+"*/\n"
print "#include \"population.h\""
print "#include \"typedef.h\""
print 
#numpy.set_printoptions(precission=18)
for x in range(0, 1):

	system_eq.append((sympy.diff(lnL, params[x]) ) )
	print "inline float_t H"+str(x)+" (const Population &P1, const Population &P2, const float_t &D) {"
	sys.stdout.write("\tfloat_t sum=0;\n")

	sys.stdout.write("\tfloat_t Q1=P1.m;\n")
	sys.stdout.write("\tfloat_t Q2=P2.m;\n")
	sys.stdout.write("\tfloat_t f=(P1.f+P2.f)/2.;\n")
	sys.stdout.write("\tint p_size=P1.likelihoods.size();\n")

	sys.stdout.write("\tfor (int x=0; x<p_size; ++x) {\n")

	sys.stdout.write("\t\tfloat_t lMM1=P1.likelihoods[x].lMM;\n")
	sys.stdout.write("\t\tfloat_t lMm1=P1.likelihoods[x].lMm;\n")
	sys.stdout.write("\t\tfloat_t lmm1=P1.likelihoods[x].lmm;\n")

	sys.stdout.write("\t\tfloat_t lMM2=P2.likelihoods[x].lMM;\n")
	sys.stdout.write("\t\tfloat_t lMm2=P2.likelihoods[x].lMm;\n")
	sys.stdout.write("\t\tfloat_t lmm2=P2.likelihoods[x].lmm;\n")
	sys.stdout.write("\t\tif (P1.likelihoods[x].N > 4 and P2. likelihoods[x].N > 4){\n")

	sys.stdout.write("\t\tsum+=")
	print_ccode(  system_eq[-1] )
	sys.stdout.write("\t;}\n")
	sys.stdout.write("\t}\n")

	sys.stdout.write("\treturn sum;\n")
	print "}\n"

#Then we need to make the Jacobian, which is a matrix with ...
for x in range(0, 1):
	for y in range(0, 1):
		print "inline float_t J"+str(x)+str(y)+" (const Population &P1, const Population &P2, const float_t &D) {"
	        sys.stdout.write("\tfloat_t sum=0;\n")

	        sys.stdout.write("\tfloat_t Q1=P1.m;\n")
	        sys.stdout.write("\tfloat_t Q2=P2.m;\n")
		sys.stdout.write("\tfloat_t f=(P1.f+P2.f)/2.;\n")
		sys.stdout.write("\tint p_size=P1.likelihoods.size();\n")

	        sys.stdout.write("\tfor (int x=0; x<p_size; ++x) {\n")

	        sys.stdout.write("\t\tfloat_t lMM1=P1.likelihoods[x].lMM;\n")
	        sys.stdout.write("\t\tfloat_t lMm1=P1.likelihoods[x].lMm;\n")
	        sys.stdout.write("\t\tfloat_t lmm1=P1.likelihoods[x].lmm;\n")

	        sys.stdout.write("\t\tfloat_t lMM2=P2.likelihoods[x].lMM;\n")
	        sys.stdout.write("\t\tfloat_t lMm2=P2.likelihoods[x].lMm;\n")
	        sys.stdout.write("\t\tfloat_t lmm2=P2.likelihoods[x].lmm;\n")

		sys.stdout.write("\t\tif (P1.likelihoods[x].N > 4 and P2. likelihoods[x].N > 4){\n")
	        sys.stdout.write("\t\tsum+=")
		print_ccode((sympy.diff(system_eq[x], params[y])))
	        sys.stdout.write("\t;}\n")
		sys.stdout.write("\t}\n")

	        sys.stdout.write("\treturn sum;\n")
	        print "}\n"


print "inline float_t lnL_NR (const Population &P1, const Population &P2, const float_t &D) {"
sys.stdout.write("\tfloat_t sum=0;\n")

sys.stdout.write("\tfloat_t Q1=P1.m;\n")
sys.stdout.write("\tfloat_t Q2=P2.m;\n")
sys.stdout.write("\tfloat_t f=(P1.f+P2.f)/2.;\n")
sys.stdout.write("\tint p_size=P1.likelihoods.size();\n")

sys.stdout.write("\tfor (int x=0; x<p_size; ++x) {\n")

sys.stdout.write("\t\tfloat_t lMM1=P1.likelihoods[x].lMM;\n")
sys.stdout.write("\t\tfloat_t lMm1=P1.likelihoods[x].lMm;\n")
sys.stdout.write("\t\tfloat_t lmm1=P1.likelihoods[x].lmm;\n")

sys.stdout.write("\t\tfloat_t lMM2=P2.likelihoods[x].lMM;\n")
sys.stdout.write("\t\tfloat_t lMm2=P2.likelihoods[x].lMm;\n")
sys.stdout.write("\t\tfloat_t lmm2=P2.likelihoods[x].lmm;\n")
sys.stdout.write("\t\tif (P1.likelihoods[x].N > 4 and P2. likelihoods[x].N > 4){\n")
sys.stdout.write("\t\tsum+=")
print_ccode(sympy.simplify(lnL) )
sys.stdout.write("\t;}\n")
sys.stdout.write("\t}\n")

sys.stdout.write("\treturn sum;\n")

print "}\n"

quit()
