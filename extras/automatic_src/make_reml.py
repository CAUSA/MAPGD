import sympy 
import sys
import redcode
from sympy.utilities.codegen import codegen
from sympy.printing import print_ccode

#The Data
lMM1=sympy.Symbol('MM1')
lMm1=sympy.Symbol('Mm1')
lmm1=sympy.Symbol('mm1')

lMM2=sympy.Symbol('MM2')
lMm2=sympy.Symbol('Mm2')
lmm2=sympy.Symbol('mm2')

data=[lMM1, lMm1, lmm1, lMM2, lMm2, lmm2]

Q1=sympy.Symbol('Q1')
Q2=sympy.Symbol('Q2')

f=sympy.Symbol('f')
#f=sympy.Symbol('f2')

P1=(1.-Q1)
P2=(1.-Q2)

#The Parameters
D=sympy.Symbol('D')

#               prob_geno[1] = pow(best_p*best_q+mlD,2.0);                                      // AB/AB
#               prob_geno[2] = pow(best_p*(1.0-best_q)-mlD, 2.0);                               // Ab/Ab
#               prob_geno[3] = pow((1.0-best_p)*best_q-mlD, 2.0);                               // aB/aB
#               prob_geno[4] = pow((1.0-best_p)*(1.0-best_q)+mlD, 2.0);                         // ab/ab
#               prob_geno[5] = 2.0*(best_p*best_q+mlD)*(best_p*(1.0-best_q)-mlD);               // AB/Ab
#               prob_geno[6] = 2.0*((1.0-best_p)*best_q-mlD)*((1.0-best_p)*(1.0-best_q)+mlD);   // aB/ab
#               prob_geno[7] = 2.0*(best_p*best_q+mlD)*((1.0-best_p)*best_q-mlD);               // AB/aB
#               prob_geno[8] = 2.0*(best_p*(1.0-best_q)-mlD)*((1.0-best_p)*(1.0-best_q)+mlD);   // Ab/ab
#               prob_geno[9] = 2.0*(best_p*best_q+mlD)*((1.0-best_p)*(1.0-best_q)+mlD);         // AB/ab
#               prob_geno[10] = 2.0*(best_p*(1.0-best_q)-mlD)*((1.0-best_p)*best_q-mlD);        // Ab/aB


#An array of the parameters.
params=[D]

redcode.set_params(params)
redcode.set_data(data)

G00=Q1*Q2+D
G10=P1*Q2-D
G01=Q1*P2-D
G11=P1*P2+D

H00=G00*G00+f*G00*(1-G00)
H10=2*G10*G00*(1-f)
H20=G10*G10+f*G10*(1-G10)
H01=2*G01*G00*(1-f)
H11=(2*G01*G10+2*G11*G00)*(1-f)
H21=2*G10*G11*(1-f)
H02=G01*G01+f*G01*(1-G01)
H12=2*G11*G01*(1-f)
H22=G11*G11+f*G11*(1-G11)

#The log likelihood equation
lnL=sympy.log( H00*lmm1*lmm2+H01*lmm1*lMm2+H02*lmm1*lMM2+H10*lMm1*lmm2+H11*lMm1*lMm2+H12*lMm1*lMM2+H20*lMM1*lmm2+H21*lMM1*lMm2+H22*lMM1*lMM2 )
#lnL=-e**2-h**2-F**2


#NEED TO ADD CONSTANTS!

system_eq=[]

#We first need the three equations we are going to try and set to zero, i.e. the first partial derivitives wrt e h and F.
print "/*This code was automatically generated by "+str(sys.argv[0])+"*/\n"
print "#include \"population.h\""
print "#include \"typedef.h\""
print "#include \"constats.h\""
print 
#numpy.set_printoptions(precission=18)
for x in range(0, 1):

	system_eq.append((sympy.diff(lnL, params[x]) ) )
	print "inline float_t H"+str(x)+" (const Population &P1, const Population &P2, const float_t &D) {"
	sys.stdout.write("\tfloat_t sum=0;\n")

	sys.stdout.write("\tfloat_t Q1=P1.m;\n")
	sys.stdout.write("\tfloat_t Q2=P2.m;\n")
	sys.stdout.write("\tfloat_t f=(P1.f+P2.f)/2.;\n")
	sys.stdout.write("\tint p_size=P1.likelihoods.size();\n")

	sys.stdout.write("\tConstants <float, std::tuple<const Population &, const Population &, const float_t &> > con(LD_CNTS, LD_ARRAY);\n")
	sys.stdout.write("\tcon.recalculate( std::tuple<const Population &, const Population &, const float_t &> (P1, P2, D));\n")

	sys.stdout.write("\tfor (int x=0; x<p_size; ++x) {\n")

	sys.stdout.write("\t\tfloat_t MM1=P1.likelihoods[x].MM;\n")
	sys.stdout.write("\t\tfloat_t Mm1=P1.likelihoods[x].Mm;\n")
	sys.stdout.write("\t\tfloat_t mm1=P1.likelihoods[x].mm;\n")

	sys.stdout.write("\t\tfloat_t MM2=P2.likelihoods[x].MM;\n")
	sys.stdout.write("\t\tfloat_t Mm2=P2.likelihoods[x].Mm;\n")
	sys.stdout.write("\t\tfloat_t mm2=P2.likelihoods[x].mm;\n")
	sys.stdout.write("\t\tif (P1.likelihoods[x].N > 0 and P2.likelihoods[x].N > 0){\n")

	sys.stdout.write("\t\tsum+=")


	out=(system_eq[-1])
	out=sympy.simplify(out)
        redcode.pre(out)
	keys=redcode.dag_sort(redcode.keys)
	for key in keys:
		out=redcode.exact_sub(out, redcode.constants[key], key)
	string=sympy.printing.ccode(out)
        print string, ";\n}\n"

##
#	print_ccode(  system_eq[-1] )
#	sys.stdout.write("\t;}\n")
	sys.stdout.write("\t}\n")

	sys.stdout.write("\treturn sum;\n")
	print "}\n"

#Then we need to make the Jacobian, which is a matrix with ...
for x in range(0, 1):
	for y in range(0, 1):
		print "inline float_t J"+str(x)+str(y)+" (const Population &P1, const Population &P2, const float_t &D) {"
	        sys.stdout.write("\tfloat_t sum=0;\n")

	        sys.stdout.write("\tfloat_t Q1=P1.m;\n")
	        sys.stdout.write("\tfloat_t Q2=P2.m;\n")
		sys.stdout.write("\tfloat_t f=(P1.f+P2.f)/2.;\n")
		sys.stdout.write("\tint p_size=P1.likelihoods.size();\n")

		sys.stdout.write("\tConstants <float, std::tuple<const Population &, const Population &, const float_t &> > con(LD_CNTS, LD_ARRAY);\n")
		sys.stdout.write("\tcon.recalculate( std::tuple<const Population &, const Population &, const float_t &> (P1, P2, D));\n")

	        sys.stdout.write("\tfor (int x=0; x<p_size; ++x) {\n")

	        sys.stdout.write("\t\tfloat_t MM1=P1.likelihoods[x].MM;\n")
	        sys.stdout.write("\t\tfloat_t Mm1=P1.likelihoods[x].Mm;\n")
	        sys.stdout.write("\t\tfloat_t mm1=P1.likelihoods[x].mm;\n")

	        sys.stdout.write("\t\tfloat_t MM2=P2.likelihoods[x].MM;\n")
	        sys.stdout.write("\t\tfloat_t Mm2=P2.likelihoods[x].Mm;\n")
	        sys.stdout.write("\t\tfloat_t mm2=P2.likelihoods[x].mm;\n")

		sys.stdout.write("\t\tif (P1.likelihoods[x].N > 0 and P2.likelihoods[x].N > 0){\n")
	        sys.stdout.write("\t\tsum+=")

	        out=(sympy.diff(system_eq[x], params[y]))
	        redcode.pre(out)
	        keys=redcode.dag_sort(redcode.keys)
	        for key in keys:
	                out=redcode.exact_sub(out, redcode.constants[key], key)
	        string=sympy.printing.ccode(out)
	        print string, ";\n}\n"

		sys.stdout.write("\t}\n")

	        sys.stdout.write("\treturn sum;\n")
	        print "}\n"


print "inline float_t lnL_NR (const Population &P1, const Population &P2, const float_t &D) {"
sys.stdout.write("\tfloat_t sum=0;\n")

sys.stdout.write("\tfloat_t Q1=P1.m;\n")
sys.stdout.write("\tfloat_t Q2=P2.m;\n")
sys.stdout.write("\tfloat_t f=(P1.f+P2.f)/2.;\n")
sys.stdout.write("\tint p_size=P1.likelihoods.size();\n")

sys.stdout.write("\tfor (int x=0; x<p_size; ++x) {\n")

sys.stdout.write("\t\tfloat_t MM1=P1.likelihoods[x].MM;\n")
sys.stdout.write("\t\tfloat_t Mm1=P1.likelihoods[x].Mm;\n")
sys.stdout.write("\t\tfloat_t mm1=P1.likelihoods[x].mm;\n")

sys.stdout.write("\t\tfloat_t MM2=P2.likelihoods[x].MM;\n")
sys.stdout.write("\t\tfloat_t Mm2=P2.likelihoods[x].Mm;\n")
sys.stdout.write("\t\tfloat_t mm2=P2.likelihoods[x].mm;\n")
sys.stdout.write("\t\tif (P1.likelihoods[x].N > 0 and P2.likelihoods[x].N > 0){\n")
sys.stdout.write("\t\tsum+=")
print_ccode(sympy.simplify(lnL) )
sys.stdout.write("\t;}\n")
sys.stdout.write("\t}\n")

sys.stdout.write("\treturn sum;\n")

print "}\n"

keys=redcode.dag_replace(keys)

for key in keys:
        print "inline void set_"+str(key).split('.')[1].replace('[','').replace(']','') +" (Constants <float, std::tuple<const Population &, const Population &, const float_t &> > &con, const std::tuple<const Population &, const Population &, const float_t &> &d) {"
        print "\tconst float_t Q1=std::get<0>(d).m;"
        print "\tconst float_t Q2=std::get<1>(d).m;"
        print "\tconst float_t f=(std::get<0>(d).f+std::get<1>(d).f)/2.;"
        print "\tconst float_t D=std::get<2>(d);"
        print "\tcon.c["+str(key).split('.')[1].replace('[','').replace(']','').strip('c')+"]=",
        string=sympy.printing.ccode(redcode.constants[key])
        print string, ";\n}\n"

print "static void (*cfn["+str(len(redcode.constants))+"])(Constants <float, std::tuple<const Population &, const Population &, const float_t &> > &, const std::tuple<const Population &, const Population &, const float_t &> &)={"+"&set_"+str(keys[0]).split('.')[1].replace('[','').replace(']',''),
for key in keys[1:]:
        print ", "+"&set_"+str(key).split('.')[1].replace('[','').replace(']','')
print "};"

print "#define LD_CNTS\t"+str(len(keys) )
print "#define LD_ARRAY\tcfn"



quit()
